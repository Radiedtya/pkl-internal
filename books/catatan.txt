========== N+1 Problem ==========
Apa itu N+1 Problem?
N+1 Problem adalah masalah query database berlebihan yang terjadi saat:
1 query dipakai untuk mengambil data utama
lalu N query tambahan dipakai untuk mengambil relasi data satu per satu

â¡ï¸ Akibatnya aplikasi jadi lambat, boros query, dan nggak efisien

2ï¸âƒ£ Contoh Kasus Sederhana

Misal:
Ada 10 produk
Setiap produk punya 1 kategori
âŒ Kode yang menyebabkan N+1 Problem
$products = Product::all();

foreach ($products as $product) {
    echo $product->category->name;
}

ğŸ” Query yang terjadi:

SELECT * FROM products

SELECT * FROM categories WHERE id = 1

SELECT * FROM categories WHERE id = 2

SELECT * FROM categories WHERE id = 3

...
â¡ï¸ Total = 1 + N query

3ï¸âƒ£ Kenapa N+1 Problem Berbahaya?
Dampak	Penjelasan
âš¡ Lambat	Query makin banyak = response time naik
ğŸ’¾ Boros resource	Database kerja lebih berat
ğŸ“‰ Tidak scalable	Data makin besar â†’ makin parah
ğŸ˜µ Sulit dideteksi	Jalan di lokal, mati di production
4ï¸âƒ£ Solusi Utama: Eager Loading

Laravel menyediakan Eager Loading untuk mengatasi N+1 Problem.

âœ… Solusi dengan with()
$products = Product::with('category')->get();

foreach ($products as $product) {
    echo $product->category->name;
}

ğŸ” Query yang terjadi:

SELECT * FROM products

SELECT * FROM categories WHERE id IN (1,2,3,...)

â¡ï¸ Hanya 2 query! ğŸ‰

5ï¸âƒ£ Perbedaan Eager vs Lazy Loading
Jenis	Penjelasan
Lazy Loading	Relasi dipanggil saat dibutuhkan
Eager Loading	Relasi diambil sejak awal
âŒ Lazy (rawan N+1)
$product->category->name;

âœ… Eager
Product::with('category')->get();

6ï¸âƒ£ N+1 di Nested Relationship

Contoh:

Order â†’ OrderItems â†’ Product

âŒ Salah
$orders = Order::all();

foreach ($orders as $order) {
    foreach ($order->items as $item) {
        echo $item->product->name;
    }
}


â¡ï¸ Query bisa puluhan kali

âœ… Benar
$orders = Order::with('items.product')->get();


â¡ï¸ Semua relasi di-load sekaligus

7ï¸âƒ£ N+1 di Blade View

N+1 sering ngumpet di Blade

âŒ Contoh di Blade
@foreach ($products as $product)
    {{ $product->category->name }}
@endforeach


Kalau category belum di-eager load â†’ N+1

âœ… Solusi

Pastikan controller:

$products = Product::with('category')->get();

8ï¸âƒ£ Menggunakan load() (Conditional Eager Loading)

Kalau datanya sudah terlanjur diambil:

$products = Product::all();
$products->load('category');


âœ”ï¸ Berguna saat kondisi tertentu

9ï¸âƒ£ Batasi Kolom Relasi (Optimasi)
Product::with(['category:id,name'])->get();


â¡ï¸ Lebih ringan & cepat

ğŸ”Ÿ Deteksi N+1 Problem
ğŸ” 1. Laravel Debugbar

Lihat jumlah query

Kalau loop â†’ query naik drastis â†’ bahaya

ğŸ” 2. DB::enableQueryLog()
DB::enableQueryLog();
// code
dd(DB::getQueryLog());

1ï¸âƒ£1ï¸âƒ£ N+1 pada count() Relasi
âŒ Salah
foreach ($categories as $category) {
    echo $category->products->count();
}

âœ… Benar
$categories = Category::withCount('products')->get();

1ï¸âƒ£2ï¸âƒ£ Best Practice Anti N+1

âœ” Selalu cek relasi di loop
âœ” Biasakan with() di controller
âœ” Jangan query di Blade
âœ” Gunakan withCount()
âœ” Aktifkan Debugbar saat development
âœ” Eager load nested relationship dari awal

1ï¸âƒ£3ï¸âƒ£ Ringkasan Singkat (Buat Catatan Cepat)

N+1 Problem terjadi ketika aplikasi menjalankan 1 query utama + banyak query tambahan akibat pemanggilan relasi di dalam loop.
Solusinya adalah Eager Loading (with()) agar relasi diambil dalam jumlah query minimal, sehingga performa aplikasi Laravel tetap optimal.